import heliopy.data.spice as spice_data
import heliopy.spice as spice
from datetime import datetime, timedelta
import astropy.units as u
import numpy as np
import matplotlib.pyplot as plt
from astropy.visualization import quantity_support
from typing import List


def kernel_loader(spacecraft: int = 2) -> spice.Trajectory:
    """
    :param spacecraft: 1 or 2 for Helios 1  or 2
    :return:
    """
    # orbiter_kernel = spice_data.get_kernel('helios' + str(spacecraft))
    # spice.furnish(orbiter_kernel)
    if spacecraft == 1 or spacecraft == 2:
        orbiter_kernel = spice_data.get_kernel('helios' + str(spacecraft))
        spice.furnish(orbiter_kernel)
        orbiter = spice.Trajectory('Helios ' + str(spacecraft))
    elif spacecraft == 'ulysses':
        orbiter_kernel = spice_data.get_kernel(str(spacecraft))
        spice.furnish(orbiter_kernel)
        orbiter = spice.Trajectory(spacecraft)
    else:
        raise NotImplementedError('The only probes that can be imported are Helios 1 , Helios 2 , Ulysses')
    return orbiter


def orbit_times_generator(start_date: str = '20/01/1976', end_date: str = '01/10/1979', interval: float = 1) -> List[
    datetime]:
    """
    Generates a list of times between the start and end dates, with 1 day intervals
    :param start_date: date at which we start considering the data
    :param end_date: date at which we stop considering the data
    :param interval: interval over which the times are returned (one day by default)
    :return:
    """
    start_time = datetime.strptime(start_date, '%d/%m/%Y')
    end_time = datetime.strptime(end_date, '%d/%m/%Y')
    times = []
    while start_time < end_time:
        times.append(start_time)
        start_time = start_time + timedelta(days=interval)
    return times


def orbit_generator(orbiter: spice.Trajectory, times: List[datetime], observing_body: str = 'Sun',
                    frame: str = 'ECLIPJ2000'):
    """
    :param orbiter: generated by kernel_loader
    :param times: times generated by orbit_times_generator
    :param observing_body: the orbit will be in the stationary frame of the observing body
    :param frame: plane to be used
    :return:
    """
    orbiter.generate_positions(times, observing_body, frame)
    orbiter.change_units(u.au)


def plot_orbit(orbiter: spice.Trajectory, spacecraft: int = 2):
    """
    :param orbiter: generated by kernel_loader
    :param spacecraft: 1 or 2 for Helios 1 or 2
    :return:
    """
    quantity_support()
    # to have nice different colors depending on time
    times_float = [(t - orbiter.times[0]).total_seconds() for t in orbiter.times]
    fig = plt.figure()
    circle = plt.Circle((0, 0), 0.004, color='r')
    ax = fig.add_subplot(111)
    # could add option to have uniform c
    ax.scatter(orbiter.x, orbiter.y, s=3, c=times_float)
    radius = np.sqrt(orbiter.x**2 + orbiter.y**2 + orbiter.z**2)
    for n in range(len(radius)):
        if 0.8*u.au<radius[n] < 0.9* u.au:
            ax.scatter(orbiter.x[n], orbiter.y[n], s=3, c='k')
    ax.scatter(orbiter.x[0], orbiter.y[0], s=5, c='b')
    ax.scatter(orbiter.x[10], orbiter.y[10], s=5, c='r')
    orbiter_venus = get_planet_orbit('Venus')
    orbiter_mercury = get_planet_orbit('Mercury')
    orbiter_earth = get_planet_orbit('Earth')
    ax.scatter(orbiter_venus.x, orbiter_venus.y, s=3, c='k')
    ax.scatter(orbiter_mercury.x, orbiter_mercury.y, s=3, c='k')
    ax.scatter(orbiter_earth.x, orbiter_earth.y, s=3, c='k')
    ax.set_xlim(-1, 1)
    ax.set_ylim(-1, 1)
    ax.set_title(
        'Orbit of Helios ' + str(spacecraft) + '  between ' + str(orbiter.times[0]) + ' and ' + str(orbiter.times[-1]))
    fig = plt.gcf()
    ax = fig.gca()
    ax.add_artist(circle)
    # for 3d:
    # fig3d = plt.figure()
    # ax = fig3d.add_subplot(111, projection='3d')
    # ax.scatter(orbiter.x, orbiter.y, orbiter.z, **kwargs)
    # ax.set_xlim(-1, 1)
    # ax.set_ylim(-1, 1)
    # ax.set_zlim(-1, 1)

    plt.show()


def plot_period(orbiter, spacecraft: int = 2):
    """
    :param orbiter: generated by kernel_loader
    :param spacecraft: 1 or 2 for Helios 1 or 2
    :return:
    """
    quantity_support()
    fig = plt.figure()
    # ax = fig.add_subplot(111)
    sun_distance = np.sqrt(orbiter.x ** 2 + orbiter.y ** 2 + orbiter.z ** 2)
    plt.plot(orbiter.times, sun_distance)
    plt.title(
        'Orbit of Helios ' + str(spacecraft) + '  between ' + str(orbiter.times[0]) + ' and ' + str(orbiter.times[-1]))
    plt.show()


def get_planet_orbit(planet: str, start_date: str = '20/01/1976', end_date: str = '01/10/1979'):
    orbiter_kernel = spice_data.get_kernel('planet_trajectories')
    spice.furnish(orbiter_kernel)
    orbiter = spice.Trajectory(planet)
    start_time = datetime.strptime(start_date, '%d/%m/%Y')
    end_time = datetime.strptime(end_date, '%d/%m/%Y')
    times = []
    while start_time < end_time:
        times.append(start_time)
        start_time = start_time + timedelta(days=1)
    orbiter.generate_positions(times, 'Sun', 'ECLIPJ2000')
    orbiter.change_units(u.au)
    return orbiter


def find_similar_dates(orbiter_spacecraft, orbiter_planet):
    position_spacecraft = np.sqrt(orbiter_spacecraft.x**2 + orbiter_spacecraft.y**2 + orbiter_spacecraft.z**2)
    position_planet = np.sqrt(orbiter_planet.x**2 + orbiter_planet.y**2 + orbiter_planet.z**2)
    similar_positions_dates = []
    for n in range(len(position_spacecraft)):
        for m in range(len(position_planet)):
            if np.abs(position_planet[m]-position_spacecraft[n]) < 0.001 * u.au:
                print(orbiter_planet.times[n], np.abs(position_planet[m]-position_spacecraft[n]))
                if orbiter_planet.times[n] not in similar_positions_dates:
                    similar_positions_dates.append(orbiter_planet.times[n])
    print(similar_positions_dates)


if __name__ == '__main__':
    probe = 1
    start_time = '15/12/1974'
    end_time = '08/08/1984'
    # probe = 2
    # probe = 'ulysses'
    orbiter = kernel_loader(probe)
    # times = orbit_times_generator(start_date='20/10/1990', end_date='30/06/2009')
    times = orbit_times_generator(start_date=start_time, end_date=end_time)
    # times = orbit_times_generator()
    orbit_generator(orbiter, times)
    radius = np.sqrt(orbiter.x ** 2 + orbiter.y ** 2 + orbiter.z ** 2)
    # print(orbiter.times)
    print('the perihelion is ', np.min(radius), ' at ', orbiter.times[np.argmin(radius)])
    print('the aphelion is ', np.max(radius), ' at ', orbiter.times[np.argmax(radius)])
    plot_orbit(orbiter, spacecraft=probe)
    # plot_period(orbiter, spacecraft=probe)
    # find_similar_dates(orbiter, get_planet_orbit('Venus))
    find_similar_dates(orbiter, get_planet_orbit('Mercury', start_time, end_time))
