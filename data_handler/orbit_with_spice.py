import heliopy.data.spice as spice_data
import heliopy.spice as spice
from datetime import datetime, timedelta
import astropy.units as u
import numpy as np
import matplotlib.pyplot as plt
from astropy.visualization import quantity_support
from typing import List


# load the kernel
def kernel_loader(spacecraft: int = 2) -> spice.Trajectory:
    """
    :param spacecraft: 1 or 2 for Helios 1  or 2
    :return:
    """
    # orbiter_kernel = spice_data.get_kernel('helios' + str(spacecraft))
    # spice.furnish(orbiter_kernel)
    if spacecraft == 1 or spacecraft == 2:
        orbiter_kernel = spice_data.get_kernel('helios' + str(spacecraft))
        spice.furnish(orbiter_kernel)
        orbiter = spice.Trajectory('Helios ' + str(spacecraft))
    elif spacecraft == 'ulysses':
        orbiter_kernel = spice_data.get_kernel(str(spacecraft))
        spice.furnish(orbiter_kernel)
        orbiter = spice.Trajectory(spacecraft)
    else:
        raise NotImplementedError('The only probes that can be imported are Helios 1 , Helios 2 , Ulysses')
    return orbiter


def orbit_times_generator(start_date: str = '20/01/1976', end_date: str = '01/10/1979', interval: float = 1) -> List[
    datetime]:
    """
    Generates a list of times between the start and end dates, with 1 day intervals
    :param start_date: date at which we start considering the data
    :param end_date: date at which we stop considering the data
    :param interval: interval over which the times are returned (one day by default)
    :return:
    """
    start_time = datetime.strptime(start_date, '%d/%m/%Y')
    end_time = datetime.strptime(end_date, '%d/%m/%Y')
    times = []
    while start_time < end_time:
        times.append(start_time)
        start_time = start_time + timedelta(days=interval)
    return times


def orbit_generator(orbiter: spice.Trajectory, times: List[datetime], observing_body: str = 'Sun',
                    frame: str = 'ECLIPJ2000'):
    """
    :param orbiter: generated by kernel_loader
    :param times: times generated by orbit_times_generator
    :param observing_body: the orbit will be in the stationary frame of the observing body
    :param frame: plane to be used
    :return:
    """
    orbiter.generate_positions(times, observing_body, frame)
    orbiter.change_units(u.au)


def plot_orbit(orbiter: spice.Trajectory, spacecraft: int = 2):
    """
    :param orbiter: generated by kernel_loader
    :param spacecraft: 1 or 2 for Helios 1 or 2
    :return:
    """
    quantity_support()
    # to have nice different colors depending on time
    times_float = [(t - orbiter.times[0]).total_seconds() for t in orbiter.times]
    fig = plt.figure()
    circle = plt.Circle((0, 0), 0.004, color='r')
    ax = fig.add_subplot(111)
    # could add option to have uniform c
    ax.scatter(orbiter.x, orbiter.y, s=3, c=times_float)
    ax.scatter(orbiter.x[0], orbiter.y[0], s=5, c='b')
    ax.scatter(orbiter.x[10], orbiter.y[10], s=5, c='r')
    ax.set_xlim(-1, 1)
    ax.set_ylim(-1, 1)
    ax.set_title(
        'Orbit of Helios ' + str(spacecraft) + '  between ' + str(orbiter.times[0]) + ' and ' + str(orbiter.times[-1]))
    fig = plt.gcf()
    ax = fig.gca()
    ax.add_artist(circle)
    # for 3d:
    # ax = fig.add_subplot(111, projection='3d')
    # ax.scatter(orbiter.x, orbiter.y, orbiter.z, **kwargs)
    # ax.set_xlim(-1, 1)
    # ax.set_ylim(-1, 1)
    # ax.set_zlim(-1, 1)

    plt.show()


def plot_period(orbiter, spacecraft: int = 2):
    """
    :param orbiter: generated by kernel_loader
    :param spacecraft: 1 or 2 for Helios 1 or 2
    :return:
    """
    quantity_support()
    fig = plt.figure()
    # ax = fig.add_subplot(111)
    sun_distance = np.sqrt(orbiter.x ** 2 + orbiter.y ** 2 + orbiter.z ** 2)
    plt.plot(orbiter.times, sun_distance)
    plt.title(
        'Orbit of Helios ' + str(spacecraft) + '  between ' + str(orbiter.times[0]) + ' and ' + str(orbiter.times[-1]))
    plt.show()


if __name__ == '__main__':
    probe = 1
    orbiter = kernel_loader(probe)
    times = orbit_times_generator()
    orbit_generator(orbiter, times)
    radius = np.sqrt(orbiter.x ** 2 + orbiter.y ** 2 + orbiter.z ** 2)
    # print(orbiter.times)
    print('the aphelion is ', np.min(radius), ' at ', orbiter.times[np.argmin(radius)])
    print('the perihelion is ', np.max(radius), ' at ', orbiter.times[np.argmax(radius)])
    # plot_orbit(orbiter)
    plot_period(orbiter, spacecraft=probe)
